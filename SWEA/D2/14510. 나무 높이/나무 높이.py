# 1이 관건임. 만약에 나무의 높이가 5 5 5 7 였다고 한다면, 채워야 하는 높이가 2 2 2 0이다. 우리가 기본적으로 생각하는 것이 이러한 차이를 모두 합하여 days = (tt_df // 3) * 2 + (tt_df % 3) 와 같이 정리하는 것임.
# 2 2 2는  D1에 1번째 +1, D2에 2번째 +2, D3에 1번째 +1, D4에 3번째 +2를 통해 4일 만에 끝남. 이와 같이 나머지의 차를 1과 2의 합으로 나타낼 때, 1과 2의 개수가 같거나 1보다 2가 많은 것은 문제가 되지 않음.
# 하지만, 1이 더 많은 경우에는 1 1 1 1 2를 예시로 들겠음. 이는 +2인 날에 1~4번째를 채울 수 없기에 1의 개수 4를 통해 4*2-1이 답이 된다.
# 여기서 핵심 : 최소 1의 개수를 파악하기. 2 3 10 5와 같은 경우에는 차이가 8 7 0 5이고 1의 총 개수를 세아리기는 어려움. 그래서 위의 예시에 착안하여 생각한다면, 1의 최소 개수를 세아리는 것이 관건임

T = int(input())
for t in range(1, T + 1):
    N = int(input())
    tree_arr = list(map(int, input().split()))
    tree_max = max(tree_arr)
    tt_df = 0  # 각 나무의 차이를 모두 합할 변수
    odd = 0    # 각 나무의 차이가 최소한 하나의 1을 가지고 있을 경우에 사용. 즉, 나무의 차이가 홀수이면 세아림 -> 필요한 1의 최소 개수를 세아리는 것

    for h in tree_arr:
        df = tree_max - h
        tt_df += df
        odd += df % 2

    # 1과 2의 개수가 동일하거나, 2의 개수가 더 많은 경우에는 days를 다음과 같이 정해도 문제가 안 됨.
    days = (tt_df // 3) * 2 + (tt_df % 3)
    #days를 위와 같이 구한다면, 1과 2의 개수 차이가 1이하라고 가정한 것. 이 경우의 1의 개수는 다음과 같이 구함.
    one_count = (days + 1) // 2

    # 1 1 1 1 2와 같이 1이 더 많은 경우에는 다음과 같은 상황이 벌어짐.
    if odd > one_count: days = 2 * odd - 1
    
    print(f'#{t} {days}')
